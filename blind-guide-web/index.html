<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0a0f">
    <meta name="description" content="AI-powered navigation assistant for visually impaired users">
    
    <title>BlindGuide AI</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-card: #1a1a24;
            --text-primary: #ffffff;
            --text-secondary: #8888aa;
            --accent-safe: #00ff88;
            --accent-warning: #ffaa00;
            --accent-danger: #ff4444;
            --accent-info: #4488ff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            height: 100%;
            overflow: hidden;
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        /* Main Container */
        .app {
            display: flex;
            flex-direction: column;
            height: 100%;
            height: 100dvh;
        }
        
        /* Camera View */
        .camera-container {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* Status Bar */
        .status-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 12px 16px;
            padding-top: max(12px, env(safe-area-inset-top));
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }
        
        .status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .status-walking {
            background: var(--accent-info);
            color: #000;
        }
        
        .status-stationary {
            background: var(--accent-safe);
            color: #000;
        }
        
        .depth-badge {
            background: var(--bg-card);
            border: 1px solid #333;
        }
        
        /* Alert Banner */
        .alert-banner {
            position: absolute;
            top: 60px;
            left: 16px;
            right: 16px;
            padding: 16px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            z-index: 20;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
            pointer-events: none;
        }
        
        .alert-banner.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .alert-banner.danger {
            background: var(--accent-danger);
            color: #fff;
            animation: pulse-danger 0.5s ease infinite;
        }
        
        .alert-banner.warning {
            background: var(--accent-warning);
            color: #000;
        }
        
        .alert-banner.info {
            background: var(--accent-info);
            color: #fff;
        }
        
        @keyframes pulse-danger {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        /* VLM Insight */
        .vlm-insight {
            position: absolute;
            bottom: 180px;
            left: 16px;
            right: 16px;
            padding: 12px 16px;
            background: rgba(68, 136, 255, 0.2);
            border: 1px solid var(--accent-info);
            border-radius: 12px;
            font-size: 14px;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .vlm-insight.visible {
            opacity: 1;
        }
        
        .vlm-insight::before {
            content: "üß† AI: ";
            font-weight: 600;
        }
        
        /* Control Panel */
        .control-panel {
            background: var(--bg-secondary);
            padding: 16px;
            padding-bottom: max(16px, env(safe-area-inset-bottom));
            border-top: 1px solid #222;
        }
        
        /* Main Action Button */
        .main-action {
            width: 100%;
            padding: 20px;
            border: none;
            border-radius: 16px;
            font-family: inherit;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 12px;
        }
        
        .main-action.listening {
            background: linear-gradient(135deg, #4488ff, #6644ff);
            color: #fff;
            animation: listening-pulse 1.5s ease infinite;
        }
        
        .main-action.idle {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 2px solid #333;
        }
        
        @keyframes listening-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(68, 136, 255, 0.4); }
            50% { box-shadow: 0 0 0 20px rgba(68, 136, 255, 0); }
        }
        
        /* Quick Actions */
        .quick-actions {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .quick-btn {
            padding: 14px 8px;
            border: none;
            border-radius: 12px;
            background: var(--bg-card);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            transition: all 0.2s ease;
        }
        
        .quick-btn:active {
            transform: scale(0.95);
            background: #252530;
        }
        
        .quick-btn .icon {
            font-size: 24px;
        }
        
        .quick-btn.active {
            background: var(--accent-info);
            color: #000;
        }
        
        /* Settings Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 100;
            display: none;
            align-items: flex-end;
            justify-content: center;
        }
        
        .modal-overlay.visible {
            display: flex;
        }
        
        .modal-content {
            width: 100%;
            max-height: 70vh;
            background: var(--bg-secondary);
            border-radius: 24px 24px 0 0;
            padding: 24px;
            padding-bottom: max(24px, env(safe-area-inset-bottom));
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }
        
        .modal-title {
            font-size: 20px;
            font-weight: 600;
        }
        
        .modal-close {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background: var(--bg-card);
            color: var(--text-primary);
            font-size: 20px;
            cursor: pointer;
        }
        
        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 0;
            border-bottom: 1px solid #222;
        }
        
        .setting-label {
            font-size: 14px;
        }
        
        .setting-desc {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        
        /* Toggle Switch */
        .toggle {
            width: 52px;
            height: 28px;
            background: #333;
            border-radius: 14px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .toggle.active {
            background: var(--accent-info);
        }
        
        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 24px;
            height: 24px;
            background: #fff;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }
        
        .toggle.active::after {
            transform: translateX(24px);
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            transition: opacity 0.5s ease;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-logo {
            font-size: 64px;
            margin-bottom: 24px;
            animation: float 2s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .loading-text {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .loading-status {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .loading-progress {
            width: 200px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 24px;
            overflow: hidden;
        }
        
        .loading-progress-bar {
            height: 100%;
            background: var(--accent-info);
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        /* Detection Boxes */
        .detection-box {
            position: absolute;
            border: 2px solid;
            border-radius: 8px;
            pointer-events: none;
        }
        
        .detection-label {
            position: absolute;
            top: -24px;
            left: 0;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
        }
        
        /* Direction Indicator */
        .direction-indicator {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 15;
        }
        
        .direction-arrow {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0,0,0,0.6);
            border: 2px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            opacity: 0.3;
            transition: all 0.3s ease;
        }
        
        .direction-arrow.active {
            opacity: 1;
            border-color: var(--accent-warning);
            background: rgba(255, 170, 0, 0.3);
        }
        
        .direction-arrow.danger {
            border-color: var(--accent-danger);
            background: rgba(255, 68, 68, 0.3);
            animation: pulse-danger 0.3s ease infinite;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-logo">ü¶Æ</div>
        <div class="loading-text">BlindGuide AI</div>
        <div class="loading-status" id="loadingStatus">Initializing...</div>
        <div class="loading-progress">
            <div class="loading-progress-bar" id="loadingProgress" style="width: 0%"></div>
        </div>
    </div>
    
    <!-- Main App -->
    <div class="app">
        <!-- Camera View -->
        <div class="camera-container">
            <video id="video" autoplay playsinline muted></video>
            <canvas id="canvas"></canvas>
            
            <!-- Status Bar -->
            <div class="status-bar">
                <span class="status-badge status-stationary" id="statusBadge">READY</span>
                <span class="status-badge depth-badge" id="depthBadge">Depth: --</span>
            </div>
            
            <!-- Alert Banner -->
            <div class="alert-banner" id="alertBanner"></div>
            
            <!-- Direction Indicators -->
            <div class="direction-indicator">
                <div class="direction-arrow" id="arrowLeft">‚Üê</div>
                <div class="direction-arrow" id="arrowAhead">‚Üë</div>
                <div class="direction-arrow" id="arrowRight">‚Üí</div>
            </div>
            
            <!-- VLM Insight -->
            <div class="vlm-insight" id="vlmInsight"></div>
        </div>
        
        <!-- Control Panel -->
        <div class="control-panel">
            <button class="main-action idle" id="mainAction">
                üé§ Tap to Ask
            </button>
            
            <div class="quick-actions">
                <button class="quick-btn" id="btnDescribe">
                    <span class="icon">üëÅÔ∏è</span>
                    Describe
                </button>
                <button class="quick-btn" id="btnSafe">
                    <span class="icon">‚úì</span>
                    Safe?
                </button>
                <button class="quick-btn active" id="btnNav">
                    <span class="icon">üß≠</span>
                    Nav
                </button>
                <button class="quick-btn" id="btnSettings">
                    <span class="icon">‚öôÔ∏è</span>
                    Settings
                </button>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Settings</span>
                <button class="modal-close" id="closeSettings">√ó</button>
            </div>
            
            <div class="setting-item">
                <div>
                    <div class="setting-label">Voice Alerts</div>
                    <div class="setting-desc">Speak obstacles and directions</div>
                </div>
                <div class="toggle active" id="toggleVoice"></div>
            </div>
            
            <div class="setting-item">
                <div>
                    <div class="setting-label">Vibration Feedback</div>
                    <div class="setting-desc">Haptic feedback for obstacles</div>
                </div>
                <div class="toggle active" id="toggleVibration"></div>
            </div>
            
            <div class="setting-item">
                <div>
                    <div class="setting-label">Sound Cues</div>
                    <div class="setting-desc">Directional audio hints</div>
                </div>
                <div class="toggle active" id="toggleSound"></div>
            </div>
            
            <div class="setting-item">
                <div>
                    <div class="setting-label">AI Scene Analysis</div>
                    <div class="setting-desc">GPT-4o for stairs, doors, etc.</div>
                </div>
                <div class="toggle active" id="toggleVLM"></div>
            </div>
            
            <div class="setting-item">
                <div>
                    <div class="setting-label">High Contrast Mode</div>
                    <div class="setting-desc">For low vision users</div>
                </div>
                <div class="toggle" id="toggleContrast"></div>
            </div>
        </div>
    </div>

    <!-- ONNX Runtime -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
    
    <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    
    const CONFIG = {
        // API Keys (replace with your own or use environment)
        OPENAI_API_KEY: "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",
        
        // Model
        MODEL_URL: "https://huggingface.co/nickmuchi/yolov11n-onnx/resolve/main/yolov11n.onnx",
        INPUT_SIZE: 640,
        CONFIDENCE_THRESHOLD: 0.4,
        
        // Zones (meters)
        ZONES: {
            immediate: 0.8,
            close: 1.5,
            awareness: 3.0
        },
        
        // Cooldowns (ms)
        COOLDOWNS: {
            voice: 8000,
            vlm: 10000,
            sound: 1500,
            vibration: 1000
        },
        
        // Classes
        CRITICAL_OBJECTS: ["car", "bus", "truck", "motorcycle", "bicycle", "train"],
        HIGH_PRIORITY: ["person", "chair", "bench", "dog", "cat", "backpack", "suitcase"],
        
        CLASS_NAMES: [
            "person", "bicycle", "car", "motorcycle", "airplane", "bus", "train",
            "truck", "boat", "traffic light", "fire hydrant", "stop sign",
            "parking meter", "bench", "bird", "cat", "dog", "horse", "sheep",
            "cow", "elephant", "bear", "zebra", "giraffe", "backpack", "umbrella",
            "handbag", "tie", "suitcase", "frisbee", "skis", "snowboard",
            "sports ball", "kite", "baseball bat", "baseball glove", "skateboard",
            "surfboard", "tennis racket", "bottle", "wine glass", "cup", "fork",
            "knife", "spoon", "bowl", "banana", "apple", "sandwich", "orange",
            "broccoli", "carrot", "hot dog", "pizza", "donut", "cake", "chair",
            "couch", "potted plant", "bed", "dining table", "toilet", "tv",
            "laptop", "mouse", "remote", "keyboard", "cell phone", "microwave",
            "oven", "toaster", "sink", "refrigerator", "book", "clock", "vase",
            "scissors", "teddy bear", "hair drier", "toothbrush"
        ]
    };
    
    // ============================================
    // STATE
    // ============================================
    
    const state = {
        model: null,
        video: null,
        canvas: null,
        ctx: null,
        isRunning: false,
        navEnabled: true,
        userState: 'stationary', // 'walking' or 'stationary'
        
        // Settings
        settings: {
            voice: true,
            vibration: true,
            sound: true,
            vlm: true,
            contrast: false
        },
        
        // Timers
        lastVoice: 0,
        lastVLM: 0,
        lastSound: {},
        lastVibration: 0,
        
        // Motion detection
        prevFrame: null,
        motionHistory: [],
        
        // Current detections
        detections: [],
        vlmResult: ''
    };
    
    // ============================================
    // AUDIO CONTEXT (Spatial Sound)
    // ============================================
    
    let audioCtx = null;
    
    function initAudio() {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    function playTone(frequency, duration, pan = 0) {
        if (!audioCtx || !state.settings.sound) return;
        
        const now = Date.now();
        const key = `tone_${pan}`;
        if (now - (state.lastSound[key] || 0) < CONFIG.COOLDOWNS.sound) return;
        state.lastSound[key] = now;
        
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        const panner = audioCtx.createStereoPanner();
        
        oscillator.type = 'sine';
        oscillator.frequency.value = frequency;
        
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        
        panner.pan.value = pan; // -1 = left, 0 = center, 1 = right
        
        oscillator.connect(gainNode);
        gainNode.connect(panner);
        panner.connect(audioCtx.destination);
        
        oscillator.start();
        oscillator.stop(audioCtx.currentTime + duration);
    }
    
    function playDirectionalSound(position, urgency = 'soft') {
        if (!state.settings.sound) return;
        
        const frequencies = {
            soft: 600,
            close: 800,
            urgent: 1000,
            immediate: 1200,
            danger: 1400
        };
        
        const durations = {
            soft: 0.1,
            close: 0.15,
            urgent: 0.12,
            immediate: 0.1,
            danger: 0.2
        };
        
        let pan = 0;
        if (position.includes('left')) pan = -0.8;
        else if (position.includes('right')) pan = 0.8;
        
        playTone(frequencies[urgency] || 600, durations[urgency] || 0.1, pan);
    }
    
    function playDangerSound() {
        if (!state.settings.sound) return;
        playTone(1400, 0.15, 0);
        setTimeout(() => playTone(1400, 0.15, 0), 150);
    }
    
    // ============================================
    // VIBRATION
    // ============================================
    
    function vibrate(pattern) {
        if (!state.settings.vibration) return;
        if (!navigator.vibrate) return;
        
        const now = Date.now();
        if (now - state.lastVibration < CONFIG.COOLDOWNS.vibration) return;
        state.lastVibration = now;
        
        navigator.vibrate(pattern);
    }
    
    function vibrateDirection(position, intensity = 'normal') {
        const patterns = {
            light: [50],
            normal: [100],
            strong: [100, 50, 100],
            danger: [200, 100, 200, 100, 200]
        };
        vibrate(patterns[intensity] || patterns.normal);
    }
    
    // ============================================
    // SPEECH
    // ============================================
    
    function speak(text, priority = 'normal') {
        if (!state.settings.voice) return;
        
        const now = Date.now();
        if (priority !== 'critical' && now - state.lastVoice < CONFIG.COOLDOWNS.voice) return;
        state.lastVoice = now;
        
        // Cancel any ongoing speech
        speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1.1;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        
        speechSynthesis.speak(utterance);
        console.log('üîä', text);
    }
    
    // ============================================
    // SPEECH RECOGNITION
    // ============================================
    
    let recognition = null;
    
    function initSpeechRecognition() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            console.warn('Speech recognition not supported');
            return;
        }
        
        recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.lang = 'en-US';
        
        recognition.onresult = (event) => {
            const text = event.results[0][0].transcript.toLowerCase();
            console.log('üé§', text);
            handleVoiceCommand(text);
        };
        
        recognition.onend = () => {
            document.getElementById('mainAction').classList.remove('listening');
            document.getElementById('mainAction').classList.add('idle');
            document.getElementById('mainAction').textContent = 'üé§ Tap to Ask';
        };
        
        recognition.onerror = (e) => {
            console.error('Speech error:', e.error);
            recognition.onend();
        };
    }
    
    function startListening() {
        if (!recognition) return;
        
        // Resume audio context (needed for iOS)
        if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        
        document.getElementById('mainAction').classList.remove('idle');
        document.getElementById('mainAction').classList.add('listening');
        document.getElementById('mainAction').textContent = 'üé§ Listening...';
        
        try {
            recognition.start();
        } catch (e) {
            console.error('Recognition error:', e);
        }
    }
    
    function handleVoiceCommand(text) {
        if (text.includes('describe') || text.includes('around') || text.includes('see')) {
            describeScene();
        } else if (text.includes('safe') || text.includes('clear') || text.includes('walk')) {
            checkSafety();
        } else if (text.includes('stop') || text.includes('pause')) {
            state.navEnabled = false;
            speak('Navigation paused');
            updateNavButton();
        } else if (text.includes('start') || text.includes('resume') || text.includes('go')) {
            state.navEnabled = true;
            speak('Navigation resumed');
            updateNavButton();
        } else if (text.includes('left')) {
            describeDirection('left');
        } else if (text.includes('right')) {
            describeDirection('right');
        } else if (text.includes('help')) {
            speak('Say: describe, is it safe, or what is on my left');
        } else {
            speak('Say describe, safe, or help');
        }
    }
    
    // ============================================
    // VLM ANALYSIS
    // ============================================
    
    async function analyzeWithVLM(imageData) {
        if (!state.settings.vlm || !CONFIG.OPENAI_API_KEY) return null;
        
        const now = Date.now();
        if (now - state.lastVLM < CONFIG.COOLDOWNS.vlm) return null;
        state.lastVLM = now;
        
        try {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${CONFIG.OPENAI_API_KEY}`
                },
                body: JSON.stringify({
                    model: 'gpt-4o',
                    messages: [{
                        role: 'user',
                        content: [
                            {
                                type: 'text',
                                text: 'You help a blind person navigate. In 1 SHORT sentence, describe ONLY critical safety info: stairs, steps, doors, wet floors, or moving objects. If nothing critical, say "Path clear". Be extremely brief.'
                            },
                            {
                                type: 'image_url',
                                image_url: {
                                    url: `data:image/jpeg;base64,${imageData}`,
                                    detail: 'low'
                                }
                            }
                        ]
                    }],
                    max_tokens: 50
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                return data.choices[0].message.content;
            }
        } catch (e) {
            console.error('VLM error:', e);
        }
        return null;
    }
    
    // ============================================
    // SCENE DESCRIPTION
    // ============================================
    
    function describeScene() {
        if (state.detections.length === 0) {
            speak('The area seems clear');
            return;
        }
        
        const items = state.detections.slice(0, 3).map(d => 
            `${d.className} ${d.position}`
        );
        speak('Around you: ' + items.join(', '));
    }
    
    function checkSafety() {
        const dangers = state.detections.filter(d => 
            d.inPath && d.depth < CONFIG.ZONES.close
        );
        
        if (dangers.length > 0) {
            speak(`Watch out for ${dangers[0].className} ahead`);
        } else {
            speak('Path seems clear');
        }
    }
    
    function describeDirection(dir) {
        const items = state.detections.filter(d => d.position.includes(dir));
        if (items.length > 0) {
            speak(`On your ${dir}: ${items[0].className}`);
        } else {
            speak(`Nothing on your ${dir}`);
        }
    }
    
    // ============================================
    // MOTION DETECTION
    // ============================================
    
    function detectMotion(imageData) {
        const data = imageData.data;
        const len = data.length;
        
        // Downsample for speed
        let sum = 0;
        const step = 100;
        for (let i = 0; i < len; i += step * 4) {
            sum += data[i]; // Just red channel
        }
        const avg = sum / (len / step / 4);
        
        if (state.prevFrame === null) {
            state.prevFrame = avg;
            return 'uncertain';
        }
        
        const diff = Math.abs(avg - state.prevFrame) / 255;
        state.prevFrame = avg;
        
        state.motionHistory.push(diff);
        if (state.motionHistory.length > 15) {
            state.motionHistory.shift();
        }
        
        const avgMotion = state.motionHistory.reduce((a, b) => a + b, 0) / state.motionHistory.length;
        
        if (avgMotion > 0.015) {
            return 'walking';
        } else if (avgMotion < 0.005) {
            return 'stationary';
        }
        return state.userState; // Keep previous
    }
    
    // ============================================
    // DEPTH ESTIMATION (Heuristic)
    // ============================================
    
    function estimateDepth(bbox) {
        const size = Math.max(bbox.width, bbox.height);
        
        if (size > 0.6) return 0.4;
        if (size > 0.45) return 0.7;
        if (size > 0.3) return 1.2;
        if (size > 0.2) return 2.0;
        if (size > 0.12) return 3.0;
        if (size > 0.07) return 4.5;
        return 6.0;
    }
    
    // ============================================
    // YOLO DETECTION
    // ============================================
    
    async function loadModel() {
        updateLoadingStatus('Loading AI model...', 30);
        
        try {
            state.model = await ort.InferenceSession.create(CONFIG.MODEL_URL, {
                executionProviders: ['webgl', 'wasm']
            });
            console.log('Model loaded');
            return true;
        } catch (e) {
            console.error('Model load error:', e);
            updateLoadingStatus('Model failed - using basic mode', 50);
            return false;
        }
    }
    
    async function detect(imageData) {
        if (!state.model) return [];
        
        const inputSize = CONFIG.INPUT_SIZE;
        
        // Create tensor from image data
        const data = new Float32Array(3 * inputSize * inputSize);
        
        // Preprocess: RGB, normalized
        for (let i = 0; i < inputSize * inputSize; i++) {
            const idx = i * 4;
            data[i] = imageData.data[idx] / 255;                    // R
            data[i + inputSize * inputSize] = imageData.data[idx + 1] / 255;     // G
            data[i + 2 * inputSize * inputSize] = imageData.data[idx + 2] / 255; // B
        }
        
        const tensor = new ort.Tensor('float32', data, [1, 3, inputSize, inputSize]);
        
        try {
            const results = await state.model.run({ images: tensor });
            const output = results[Object.keys(results)[0]];
            return postprocess(output);
        } catch (e) {
            console.error('Detection error:', e);
            return [];
        }
    }
    
    function postprocess(output) {
        const detections = [];
        const data = output.data;
        const [batch, features, numBoxes] = output.dims;
        
        for (let i = 0; i < numBoxes; i++) {
            // Get box data
            const x = data[0 * numBoxes + i];
            const y = data[1 * numBoxes + i];
            const w = data[2 * numBoxes + i];
            const h = data[3 * numBoxes + i];
            
            // Get class scores
            let maxScore = 0;
            let classId = 0;
            for (let c = 0; c < 80; c++) {
                const score = data[(4 + c) * numBoxes + i];
                if (score > maxScore) {
                    maxScore = score;
                    classId = c;
                }
            }
            
            if (maxScore < CONFIG.CONFIDENCE_THRESHOLD) continue;
            
            const className = CONFIG.CLASS_NAMES[classId];
            
            // Normalize coordinates
            const bbox = {
                x: (x - w / 2) / CONFIG.INPUT_SIZE,
                y: (y - h / 2) / CONFIG.INPUT_SIZE,
                width: w / CONFIG.INPUT_SIZE,
                height: h / CONFIG.INPUT_SIZE
            };
            
            // Calculate center and position
            const cx = bbox.x + bbox.width / 2;
            let position = 'ahead';
            if (cx < 0.3) position = 'far left';
            else if (cx < 0.45) position = 'left';
            else if (cx > 0.7) position = 'far right';
            else if (cx > 0.55) position = 'right';
            
            // Check if in path
            const inPath = cx > 0.3 && cx < 0.7;
            
            // Estimate depth
            const depth = estimateDepth(bbox);
            
            // Determine priority
            let priority = 'low';
            if (CONFIG.CRITICAL_OBJECTS.includes(className)) priority = 'critical';
            else if (CONFIG.HIGH_PRIORITY.includes(className)) priority = 'high';
            
            detections.push({
                className,
                confidence: maxScore,
                bbox,
                position,
                depth,
                priority,
                inPath
            });
        }
        
        // Sort by priority and depth
        detections.sort((a, b) => {
            const priorityOrder = { critical: 0, high: 1, low: 2 };
            if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
                return priorityOrder[a.priority] - priorityOrder[b.priority];
            }
            if (a.inPath !== b.inPath) return a.inPath ? -1 : 1;
            return a.depth - b.depth;
        });
        
        return detections.slice(0, 10); // Limit to top 10
    }
    
    // ============================================
    // NAVIGATION ADVISOR
    // ============================================
    
    function advise() {
        if (!state.navEnabled) return;
        
        const relevant = state.detections.find(d => 
            d.priority !== 'low' || d.inPath
        );
        
        if (!relevant) {
            clearDirectionIndicators();
            return;
        }
        
        // Update direction indicators
        updateDirectionIndicators(relevant);
        
        if (state.userState === 'stationary') {
            handleStationary(relevant);
        } else {
            handleWalking(relevant);
        }
    }
    
    function handleWalking(obs) {
        if (obs.depth < CONFIG.ZONES.immediate) {
            // IMMEDIATE - Act now!
            playDirectionalSound(obs.position, 'immediate');
            vibrateDirection(obs.position, 'strong');
            
            const dir = obs.position.includes('left') ? 'right' : 
                        obs.position.includes('right') ? 'left' : 'back';
            speak(`Go ${dir}!`, 'critical');
            
            showAlert(`‚ö†Ô∏è ${obs.className.toUpperCase()} - Go ${dir}!`, 'danger');
            
        } else if (obs.depth < CONFIG.ZONES.close) {
            // CLOSE - Prepare
            playDirectionalSound(obs.position, 'close');
            vibrateDirection(obs.position, 'normal');
            
        } else if (obs.depth < CONFIG.ZONES.awareness) {
            // AWARENESS - Just notice
            playDirectionalSound(obs.position, 'soft');
        }
    }
    
    function handleStationary(obs) {
        if (obs.priority === 'critical' && obs.depth < CONFIG.ZONES.close) {
            playDangerSound();
            vibrate([200, 100, 200]);
            speak(`Danger! ${obs.className} nearby!`, 'critical');
            showAlert(`üö® ${obs.className.toUpperCase()} NEARBY!`, 'danger');
        }
    }
    
    // ============================================
    // UI UPDATES
    // ============================================
    
    function updateLoadingStatus(text, progress) {
        document.getElementById('loadingStatus').textContent = text;
        document.getElementById('loadingProgress').style.width = `${progress}%`;
    }
    
    function hideLoading() {
        document.getElementById('loadingScreen').classList.add('hidden');
    }
    
    function showAlert(text, type = 'info') {
        const banner = document.getElementById('alertBanner');
        banner.textContent = text;
        banner.className = `alert-banner visible ${type}`;
        
        setTimeout(() => {
            banner.classList.remove('visible');
        }, 3000);
    }
    
    function showVLMInsight(text) {
        const insight = document.getElementById('vlmInsight');
        insight.textContent = text;
        insight.classList.add('visible');
        
        setTimeout(() => {
            insight.classList.remove('visible');
        }, 5000);
    }
    
    function updateStatusBadge() {
        const badge = document.getElementById('statusBadge');
        if (state.userState === 'walking') {
            badge.textContent = 'WALKING';
            badge.className = 'status-badge status-walking';
        } else {
            badge.textContent = 'STATIONARY';
            badge.className = 'status-badge status-stationary';
        }
    }
    
    function updateNavButton() {
        const btn = document.getElementById('btnNav');
        if (state.navEnabled) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    }
    
    function updateDirectionIndicators(obs) {
        const left = document.getElementById('arrowLeft');
        const ahead = document.getElementById('arrowAhead');
        const right = document.getElementById('arrowRight');
        
        // Reset
        left.className = 'direction-arrow';
        ahead.className = 'direction-arrow';
        right.className = 'direction-arrow';
        
        const isDanger = obs.depth < CONFIG.ZONES.immediate;
        const activeClass = isDanger ? 'active danger' : 'active';
        
        if (obs.position.includes('left')) {
            left.className = `direction-arrow ${activeClass}`;
        } else if (obs.position.includes('right')) {
            right.className = `direction-arrow ${activeClass}`;
        } else {
            ahead.className = `direction-arrow ${activeClass}`;
        }
    }
    
    function clearDirectionIndicators() {
        document.getElementById('arrowLeft').className = 'direction-arrow';
        document.getElementById('arrowAhead').className = 'direction-arrow';
        document.getElementById('arrowRight').className = 'direction-arrow';
    }
    
    function drawDetections() {
        const ctx = state.ctx;
        const video = state.video;
        const canvas = state.canvas;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const scaleX = canvas.width;
        const scaleY = canvas.height;
        
        for (const det of state.detections) {
            const x = det.bbox.x * scaleX;
            const y = det.bbox.y * scaleY;
            const w = det.bbox.width * scaleX;
            const h = det.bbox.height * scaleY;
            
            // Color based on priority
            let color = '#00ff88';
            if (det.priority === 'critical') color = '#ff4444';
            else if (det.priority === 'high') color = '#ffaa00';
            
            // Thicker if in path
            ctx.lineWidth = det.inPath ? 3 : 2;
            ctx.strokeStyle = color;
            ctx.strokeRect(x, y, w, h);
            
            // Label
            ctx.fillStyle = color;
            ctx.font = '12px JetBrains Mono';
            ctx.fillText(`${det.className} ${det.depth.toFixed(1)}m`, x, y - 5);
        }
    }
    
    // ============================================
    // MAIN LOOP
    // ============================================
    
    async function processFrame() {
        if (!state.isRunning) return;
        
        const video = state.video;
        const canvas = state.canvas;
        const ctx = state.ctx;
        
        // Draw video to canvas
        ctx.drawImage(video, 0, 0, CONFIG.INPUT_SIZE, CONFIG.INPUT_SIZE);
        const imageData = ctx.getImageData(0, 0, CONFIG.INPUT_SIZE, CONFIG.INPUT_SIZE);
        
        // Detect motion
        state.userState = detectMotion(imageData);
        updateStatusBadge();
        
        // Run detection
        state.detections = await detect(imageData);
        
        // Update depth badge
        if (state.detections.length > 0) {
            const closest = state.detections[0].depth;
            document.getElementById('depthBadge').textContent = `Closest: ${closest.toFixed(1)}m`;
        } else {
            document.getElementById('depthBadge').textContent = 'Clear';
        }
        
        // Draw detections
        canvas.width = video.videoWidth || 640;
        canvas.height = video.videoHeight || 480;
        drawDetections();
        
        // Navigation advice
        advise();
        
        // VLM analysis (when walking)
        if (state.userState === 'walking' && state.settings.vlm) {
            const base64 = canvas.toDataURL('image/jpeg', 0.5).split(',')[1];
            const vlmResult = await analyzeWithVLM(base64);
            if (vlmResult && !vlmResult.toLowerCase().includes('clear')) {
                state.vlmResult = vlmResult;
                showVLMInsight(vlmResult);
                speak(vlmResult);
            }
        }
        
        // Next frame
        requestAnimationFrame(processFrame);
    }
    
    // ============================================
    // INITIALIZATION
    // ============================================
    
    async function initCamera() {
        updateLoadingStatus('Accessing camera...', 60);
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'environment',
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                },
                audio: false
            });
            
            state.video.srcObject = stream;
            await state.video.play();
            
            return true;
        } catch (e) {
            console.error('Camera error:', e);
            updateLoadingStatus('Camera access denied', 60);
            alert('Please allow camera access to use this app');
            return false;
        }
    }
    
    async function init() {
        // Get elements
        state.video = document.getElementById('video');
        state.canvas = document.getElementById('canvas');
        state.ctx = state.canvas.getContext('2d');
        
        // Initialize audio
        initAudio();
        
        // Initialize speech recognition
        initSpeechRecognition();
        
        // Load model
        const modelLoaded = await loadModel();
        
        // Initialize camera
        updateLoadingStatus('Starting camera...', 70);
        const cameraReady = await initCamera();
        
        if (!cameraReady) return;
        
        // Setup UI
        setupUI();
        
        updateLoadingStatus('Ready!', 100);
        
        // Hide loading screen
        setTimeout(() => {
            hideLoading();
            speak('BlindGuide ready. Tap the microphone to ask questions.');
            state.isRunning = true;
            processFrame();
        }, 500);
    }
    
    function setupUI() {
        // Main action button (voice)
        document.getElementById('mainAction').addEventListener('click', () => {
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            startListening();
        });
        
        // Quick actions
        document.getElementById('btnDescribe').addEventListener('click', () => {
            describeScene();
        });
        
        document.getElementById('btnSafe').addEventListener('click', () => {
            checkSafety();
        });
        
        document.getElementById('btnNav').addEventListener('click', () => {
            state.navEnabled = !state.navEnabled;
            speak(state.navEnabled ? 'Navigation on' : 'Navigation off');
            updateNavButton();
        });
        
        document.getElementById('btnSettings').addEventListener('click', () => {
            document.getElementById('settingsModal').classList.add('visible');
        });
        
        document.getElementById('closeSettings').addEventListener('click', () => {
            document.getElementById('settingsModal').classList.remove('visible');
        });
        
        // Settings toggles
        setupToggle('toggleVoice', 'voice');
        setupToggle('toggleVibration', 'vibration');
        setupToggle('toggleSound', 'sound');
        setupToggle('toggleVLM', 'vlm');
        setupToggle('toggleContrast', 'contrast');
    }
    
    function setupToggle(elementId, setting) {
        const el = document.getElementById(elementId);
        el.addEventListener('click', () => {
            state.settings[setting] = !state.settings[setting];
            el.classList.toggle('active', state.settings[setting]);
            
            if (setting === 'contrast') {
                document.body.style.filter = state.settings.contrast ? 
                    'contrast(1.5) saturate(0)' : 'none';
            }
        });
    }
    
    // Register service worker for PWA
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js')
            .then(reg => console.log('SW registered'))
            .catch(err => console.log('SW failed:', err));
    }
    
    // Start app when page loads
    window.addEventListener('load', init);
    
    // Handle visibility change (pause when app is backgrounded)
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            state.isRunning = false;
        } else {
            state.isRunning = true;
            processFrame();
        }
    });
    </script>
</body>
</html>
